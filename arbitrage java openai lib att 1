import com.xrpl.xrpl4j.XRPL;
import com.xrpl.xrpl4j.XRPLClient;
import com.xrpl.xrpl4j.exceptions.XRPLException;
import com.xrpl.xrpl4j.model.AccountInfo;
import com.xrpl.xrpl4j.model.Currency;
import com.xrpl.xrpl4j.model.Price;
import com.xrpl.xrpl4j.model.Transaction;

import java.util.List;

public class Main {
  public static void main(String[] args) {
    // Create an XRPLClient with the default test net URL.
    XRPLClient client = XRPLClient.newBuilder().build();

    // Get the list of supported currencies.
    List<Currency> currencies = client.getCurrencies().getResult();

    // Initialize a Bellman-Ford graph with the number of vertices equal to the number of currencies.
    int numCurrencies = currencies.size();
    int[][] graph = new int[numCurrencies][numCurrencies];

    // Initialize the graph with the prices of each currency relative to XRP.
    for (int i = 0; i < numCurrencies; i++) {
      Currency currency = currencies.get(i);
      String currencyCode = currency.getCode();

      // Get the price of the currency relative to XRP.
      Price price = client.getPrice(currencyCode, "XRP").getResult();
      double priceInXRP = price.getPrice();

      // Add the price to the graph as a weighted edge.
      for (int j = 0; j < numCurrencies; j++) {
        graph[i][j] = (int) (priceInXRP * 100);
      }
    }

    // Use the Bellman-Ford algorithm to detect negative weight cycles in the graph.
    boolean hasNegativeCycle = bellmanFord(graph, numCurrencies);
    if (hasNegativeCycle) {
      System.out.println("The graph contains a negative weight cycle.");
    } else {
      System.out.println("The graph does not contain a negative weight cycle.");
    }

    // Get the secret key and address of the account you want to sign a transaction for.
    String secretKey = "your secret key here";
    String address = "your address here";

    // Create a new transaction.
    Transaction transaction = new Transaction.Builder()
        .setAccount(address)
        .build();

    // Sign the transaction with the secret key.
    try {
      transaction = client.sign(transaction, secretKey).getResult();
    } catch (XRPLException e) {
      System.out.println("Error signing transaction: " + e.getMessage());
    }
  }
  // The Bellman-Ford algorithm to detect negative weight cycles in a graph.
  public static boolean bellmanFord(int[][] graph, int numVertices) {
    // Initialize the distance array with infinite distance values.
    int[] distances = new int[numVertices];
    for (int i = 0; i < numVertices; i++) {
      distances[i] = Integer.MAX_VALUE;
    }
  
    // Set the distance to the first vertex to be 0.
    distances[0] = 0;
  
    // Relax the edges numVertices - 1 times.
    for (int i = 0; i < numVertices - 1; i++) {
      for (int j = 0; j < numVertices; j++) {
        for (int k = 0; k < numVertices; k++) {
          // If the distance to the destination vertex can be improved, update it.
          if (distances[j] != Integer.MAX_VALUE && distances[k] > distances[j] + graph[j][k]) {
            distances[k] = distances[j] + graph[j][k];
          }
        }
      }
    }
  
    // Check for negative weight cycles.
    for (int j = 0; j < numVertices; j++) {
      for (int k = 0; k < numVertices; k++) {
        if (distances[j] != Integer.MAX_VALUE && distances[k] > distances[j] + graph[j][k]) {
          return true;
        }
      }
    }
  
    return false;
  }
  